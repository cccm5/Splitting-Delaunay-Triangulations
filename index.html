<!DOCTYPE html>
<meta charset="utf-8">

<head>
</head>

<body>
  <div class="border">
    <div style="text-align: center">
      <h1 class="title">Splitting Delaunay Triangulations</h1>
    </div>
    <div class="flex-container">
      <div class="interface">
        <button type=button class="button1">Run</button>
        <button type=button class="button2">Reset</button>
        <div class="slidecontainer">
          <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
        </div>
      </div>
      <div class="image">
        <svg width="960" height="500" class="boxed"></svg>
      </div>
    </div>
  </div>


<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/delaunator@3.0.2/delaunator.js"></script>
<script src="https://unpkg.com/tinyqueue@2.0.0/tinyqueue.min.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
// const points = [[0, 0], [0, 100], [100, 0], [100, 100], [200, 200], [20, 20]]
const points = Array.from({length: 80}, ()=> [Math.floor(Math.random()*width), Math.floor(Math.random()*height)])
const delaunay = Delaunator.from(points);
const triangles = delaunay.hull
const blue = '#6F97A8'
const purple = '#BC95E1'
const red = '#82204A'
// console.log(triangles);
// for (let i = 1; i < triangles.length; i ++) {
//   svg.append("line")
//   .attr("x1", points[triangles[i]][0])
//   .attr("y1", points[triangles[i]][1])
//   .attr("x2", points[triangles[i-1]][0])
//   .attr("y2", points[triangles[i-1]][1])
//   .attr("stroke-width", 2)
//   .attr("stroke", "lightgrey");
//   console.log(points[triangles[i]])
// }
const splitPos = Math.floor(Math.random()*points.length)
const S1 = points.slice(0,splitPos)
const S2 = points.slice(splitPos)
var graph = new Object();
var graph1 = new Object();
var graph2 = new Object();
for(let i = 0; i < points.length; i++){
  graph[points[i]] = []
  graph1[points[i]] = []
  graph2[points[i]] = []
}
forEachTriangleEdge(points, delaunay, (_,b,c) => {
  drawEdge(b,c,svg)
  graph[b].push(c)
  if(S1.includes(b) && S1.includes(c)){
    graph1[b].push(c)
  } else if (S2.includes(b) && S2.includes(c)){
    graph2[b].push(c)
  }
})
// console.info(graph1)
// console.info(graph2)
// console.info(graph)
for(let i = 0; i < points.length; i++){
  let circ = svg.append("circle")
  .attr('cx', points[i][0])
  .attr('cy', points[i][1])
  .attr('r', 5)
  if(S1.includes(points[i])){
    circ.attr('fill',blue)
  } else{
    circ.attr('fill',purple)
  }
}

const sleep = (milliseconds) => {
  return new Promise(resolve => setTimeout(resolve, milliseconds))
}
doAlgo()
function doAlgo(){
  const doSomething = async () =>{
    const recurrantStep = async () => {
      let p1 = points[Math.floor(Math.random() * points.length)]
      let p2 = points[Math.floor(Math.random() * points.length)]
      svg.select(getCircleAttributeString(p1))
      .attr('r', 10)
      .attr('stroke',red)
      .attr('stroke-width', 4)
      svg.select(getCircleAttributeString(p2))
      .attr('r', 10)
      .attr('stroke',red)
      .attr('stroke-width', 4)
      
      const findNeigbor= async(point) => {
        var currentGraph;
        var currentPosset
        if(S1.includes(point)){
          currentGraph = graph1
          currentPosset = S1
        } else {
          // It must be in S2
          currentGraph = graph2
          currentPosset = S2
        }
        var queue = new TinyQueue(data = [], compare=(x,y) => magnitudeSquared(point,x) - magnitudeSquared(point,y))
        graph[point].forEach((el) => queue.push(el))
        let nearest = queue.pop()
        let last = point
        svg.select(getLineAttributeString(point,nearest)).attr('stroke', red)
        let visited = [point,nearest]
        console.info(queue)
        while(!currentPosset.includes(nearest)){
          console.info(`${nearest}`)
          graph[nearest].forEach((el) => queue.push(el))
          console.info(queue)
          last = nearest
          nearest = queue.pop()
          svg.select(getLineAttributeString(last,nearest)).attr('stroke', red)
        }
        
        return nearest
      } 
      // console.log(await Promise.all([findNeigbor(p1), findNeigbor(p2)]))
      await findNeigbor(p1)
      // await sleep(2000)
      // svg.select(getCircleAttributeString(p1))
      // .attr('r', 3)
      // .attr('stroke',"")
      // svg.select(getCircleAttributeString(p2))
      // .attr('r', 3)
      // .attr('stroke',"")
      
      // console.log("Hi")
    }
    recurrantStep()
    // for(let i = 0; i < points.length; i++){
    //   await sleep(500)
    //   svg.select(getCircleAttributeString(points[i]))
    //   .attr('fill', 'red')
    //   console.log(points[i])
    // }
  }
  doSomething();
}

function magnitudeSquared(p1, p2){
  return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1])
}
function getCircleAttributeString(point){
  return `circle[cx='${point[0]}'][cy='${point[1]}']`
}

function getLineAttributeString(p1, p2){
  var a = p1,b=p2;
  if(p1[0] > p2[0]){
    a = p2
    b = p1
  } else if (p1[0] == p2[0]){
    if(p1[1] > p2[1]){
      a = p2
      b = p1
    }
  }
  return `line[x1='${a[0]}'][x2='${b[0]}'][y1='${a[1]}'][y2='${b[1]}']`
}

function drawEdge(p1, p2) {
  var a = p1,b=p2;
  if(p1[0] > p2[0]){
    a = p2
    b = p1
  } else if (p1[0] == p2[0]){
    if(p1[1] > p2[1]){
      a = p2
      b = p1
    }
  }
  svg.append("line")
  .attr("x1", p1[0])
  .attr("y1", p1[1])
  .attr("x2", p2[0])
  .attr("y2", p2[1])
  .attr("stroke-width", 2)
  .attr("stroke", "lightgrey");
}



function edgesOfTriangle(t) { return [3 * t, 3 * t + 1, 3 * t + 2]; }
function triangleOfEdge(e)  { return Math.floor(e / 3); }
function nextHalfedge(e) { return (e % 3 === 2) ? e - 2 : e + 1; }
function prevHalfedge(e) { return (e % 3 === 0) ? e + 2 : e - 1; }

function forEachTriangleEdge(points, delaunay, callback) {
    for (let e = 0; e < delaunay.triangles.length; e++) {
        if (e > delaunay.halfedges[e]) {
            const p = points[delaunay.triangles[e]];
            const q = points[delaunay.triangles[nextHalfedge(e)]];
            callback(e, p, q);
        }
    }
}

function edgesOfTriangle(t) { return [3 * t, 3 * t + 1, 3 * t + 2]; }

function pointsOfTriangle(delaunay, t) {
    return edgesOfTriangle(t)
        .map(e => delaunay.triangles[e]);
}

function forEachTriangle(points, delaunay, callback) {
    for (let t = 0; t < delaunay.triangles.length / 3; t++) {
        callback(t, pointsOfTriangle(delaunay, t).map(p => points[p]));
    }
}

</script>

<style>



.triangles {
  fill: none;
}

.links {
  stroke: #000;
}

.sites {
  fill: #000;
  stroke: #fff;
}

.triangles .primary {
  fill: #f00;
}

.links .primary {
  stroke: #fff;
}

.sites :first-child {
  fill: #fff;
}

.title {
  font-family: Arial;
}

.boxed {
  text-align: right;
  padding: 20px;
  border: 2px solid lightgrey;
  border-left: 0px;
  border-right: 0px;
  border-bottom: 0px;
  float: right;
  height: 500px;
  position: relative;
}


.image {
  background-color: white;
}

.interface {
  width: 100%;
    border: 2px solid lightgrey;
    padding: 30px;
    margin: 0px;
    text-align: center;
    border-left: 0px;
    border-bottom: 0px;
  position: relative;
}

.interface:after {
  content: '';
  display: block;
  position: absolute;
  height: 15px;
  width: 30px;
  top: 0px;
  right: -5px;
  border: 5px solid white;
}


.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}


.button1 {
  background-color: #f44336; 
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
}

.button2 {
  background-color: #008CBA;
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
}

.slidecontainer {
  width: 100%; 
  position: relative;
  top: 50%;
}

.slider {
  -webkit-appearance: none;  
  appearance: none;
  width: 100%; 
  height: 15px; 
  background: #d3d3d3; 
  outline: none;
  opacity: 0.7; 
  -webkit-transition: .2s; 
  transition: opacity .2s;
  
  top: 40%;
  transform: rotate(270deg);
}


.slider:hover {
  opacity: 1; 
}


.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
}

</style>

</body>
