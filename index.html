<!DOCTYPE html>
<meta charset="utf-8">

<head>
</head>

<body>
  <div style="text-align: center">
      <h1 class="title">Splitting Delaunay Triangulations</h1>
  </div>
  <div class="border">
    <div class="flex-container">
      <div class="interface">
        <button class="button1" id="run">Run</button>
        <button class="button2" value="Reload Page" onClick="document.location.reload(true)">Reset</button>
        <div class="slidecontainer">
          <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
        </div>
        <p id="demo"></p>
        <div class="consolebox">
          <p id="insert"></p>
        </div>
      </div>
      <div class="image">
        <svg width="960" height="500" class="boxed"></svg>
      </div>
    </div>
  </div>


<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/delaunator@3.0.2/delaunator.js"></script>
<script src="https://unpkg.com/tinyqueue@2.0.0/tinyqueue.min.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
// const points = [[0, 0], [0, 100], [100, 0], [100, 100], [200, 200], [20, 20]]
const points = Array.from({length: 200}, ()=> [10+Math.floor(Math.random()*(width-20)), Math.floor(10 + Math.random()*(height-20))])
var delaunay = Delaunator.from(points);
var delaunayLines = []
const triangles = delaunay.hull
const blue = '#6F97A8'
const purple = '#BC95E1'
const red = '#82204A'
const orange = '#DDA448'

var triangulation1, triangulation2, tpoint1 = [], tpoint2 = [], tlines1=[], tlines2=[]

var slider = document.getElementById("myRange");
var setTime = slider.value
var output = document.getElementById("demo");
output.innerHTML = slider.value; // Display the default slider value

slider.oninput = function() {
  output.innerHTML = this.value;
  setTime = this.value
}


function setProgress(progress){
  document.getElementById("insert").innerHTML='> ' + progress
}


// console.log(triangles);
// for (let i = 1; i < triangles.length; i ++) {
//   svg.append("line")
//   .attr("x1", points[triangles[i]][0])
//   .attr("y1", points[triangles[i]][1])
//   .attr("x2", points[triangles[i-1]][0])
//   .attr("y2", points[triangles[i-1]][1])
//   .attr("stroke-width", 2)
//   .attr("stroke", "lightgrey");
//   console.log(points[triangles[i]])
// }
const splitPos = Math.floor(Math.random()*points.length)
const S1 = points.slice(0,splitPos)
const S2 = points.slice(splitPos)
var graph = new Object();
// var graph1 = new Object();
// var graph2 = new Object();


function drawDelaunay(){
  delaunayLines.forEach((line) => line.remove())
  delaunayLines = []
  forEachTriangleEdge(points, delaunay, (_,b,c) => {
    if(b==c)
      return
    
    delaunayLines.push(drawEdge(b,c,svg))
  })
}

function redrawDelaunay(delaunay, points, lines){
  console.info(delaunay)
  console.info(points)
  console.info(lines)
  lines.forEach((line) => line.remove())
  lines.length = 0
  forEachTriangleEdge(points, delaunay, (_, b, c)=> {
    if(b==c)
      return
    console.info(`(${b}) (${c})`)
    lines.push(drawEdge(b,c,svg))
    if(S1.includes(b)){
      lines[lines.length - 1].attr('stroke', blue)
    } else {
      lines[lines.length - 1].attr('stroke', purple)
    }
  })
}

function buildDelaunayGraph(){
  for(let i = 0; i < points.length; i++){
    graph[points[i]] = []
    // graph1[points[i]] = []
    // graph2[points[i]] = []
  }
  forEachTriangleEdge(points, delaunay, (_,b,c) => {
    if(b==c)
      return
    graph[b].push(c)
    graph[c].push(b)
    // if(S1.includes(b) && S1.includes(c)){
    //   graph1[b].push(c)
    // } else if (S2.includes(b) && S2.includes(c)){
    //   graph2[b].push(c)
    // }
  })
}

buildDelaunayGraph()
drawDelaunay()
// console.info(graph1)
// console.info(graph2)
// console.info(graph)
for(let i = 0; i < points.length; i++){
  let circ = svg.append("circle")
  .attr('cx', points[i][0])
  .attr('cy', points[i][1])
  .attr('r', 5)
  if(S1.includes(points[i])){
    circ.attr('fill',blue)
  } else{
    circ.attr('fill',purple)
  }
}

const sleep = (milliseconds) => {
  return new Promise(resolve => setTimeout(resolve, milliseconds))
}

document.getElementById("run").onclick = function() {doAlgo()};



function doAlgo(){
  var btn = document.getElementById('run');
  btn.disabled = true;
  const doSomething = async () =>{
    // await sleep(1000)
    const recurrantStep = async () => {
      if(points.length < 4){
        return
      }
      setProgress("Pick 2 random points")
      let p1 = points[Math.floor(Math.random() * points.length)]
      let p2 = points[Math.floor(Math.random() * points.length)]
      svg.select(getCircleAttributeString(p1))
      .attr('r', 10)
      .attr('stroke',red)
      .attr('stroke-width', 4)
      svg.select(getCircleAttributeString(p2))
      .attr('r', 10)
      .attr('stroke',red)
      .attr('stroke-width', 4)
      await sleep(slider.value * 10)
      const findNeigbor= async(point) => {
        // var currentGraph;
        var currentPosset
        if(S1.includes(point)){
          // currentGraph = graph1
          currentPosset = S1
        } else {
          // It must be in S2
          // currentGraph = graph2
          currentPosset = S2
        }
        var queue = new TinyQueue(data = [], compare=(x,y) => magnitudeSquared(point,x) - magnitudeSquared(point,y))
        graph[point].forEach((el) => queue.push(el))
        let nearest = queue.pop()
        while(points.indexOf(nearest) < 0){
          if(queue.length == 0){
            console.error("empty queue")
            break
          }
          nearest = queue.pop()
        }
        let last = point
        // console.info("Drawing edge")
        // await sleep(2000);
        setProgress("Find Nearest Neighbors")
        // console.info(svg.select(getLineAttributeString(point,nearest)).attr('stroke', red))
        let edges = [drawSearchRadius(point,Math.sqrt(magnitudeSquared(point, nearest)))]
        let visited = [point,nearest]
        // console.info(queue)
        // console.info(graph[point])
        let length = 1
        while(!currentPosset.includes(nearest)){
          if(queue.length == 0){
            console.error("empty queue")
            break
          }
          // await sleep(1000)
          length += 1
          graph[nearest].forEach((el) => queue.push(el))
          visited.push(nearest)
          last = nearest
          nearest = queue.pop()
          while(points.indexOf(nearest) < 0){
            if(queue.length == 0){
              console.error("empty queue")
              break
            }
            nearest = queue.pop()
          }
          // while(visited.includes(nearest)){
          //   if(queue.length == 0){
          //     console.error("empty queue")
          //     break
          //   }
          //   nearest = queue.pop()
          // }
          // svg.select(getLineAttributeString(last,nearest)).attr('stroke', red)
          edges.push(drawSearchRadius(point, Math.sqrt(magnitudeSquared(point, nearest))))
        }
        await sleep(slider.value * 10)
        
        let edge = drawEdge(point,nearest).attr('stroke',red)
        d3.select(getCircleAttributeString(point)).raise()
        d3.select(getCircleAttributeString(nearest)).raise()
        await sleep(slider.value * 10)
        edges.forEach((edge) => edge.remove())
        return {origin: point,nearest: nearest,depth: length, edge: edge}
      } 
      searches = await Promise.all([findNeigbor(p1), findNeigbor(p2)])
      await sleep(slider.value * 10)
      setProgress("Select the first located nearest neighbor")
      var first, second
      if(searches[0].depth < searches[1].depth){
        first = searches[0]
        second = searches[1]
        second.edge.remove()
      } else {
        first = searches[1]
        second = searches[0]
        second.edge.remove()
      }
      // console.info(getLineAttributeString(second.origin, second.nearest))
      // d3.selectAll(getLineAttributeString(second.origin, second.nearest)).select(`[stroke='${red}']`).remove()
      d3.select(getCircleAttributeString(second.origin))
      .attr('stroke', '')
      .attr('stroke-width','')
      .attr('r',5)
      d3.select(getCircleAttributeString(first.origin)).attr('stroke',orange)
      
      await sleep(slider.value * 10)
      setProgress("Remove the first point from Dt(S)")
      let p = first.origin
      let q = first.nearest
      points.splice(points.indexOf(p),1)
      delaunay = Delaunator.from(points)
      buildDelaunayGraph()
      drawDelaunay()
      d3.selectAll(`circle`).raise()
      
      // await findNeigbor(p1)
      // await sleep(2000)
      // svg.select(getCircleAttributeString(p1))
      // .attr('r', 3)
      // .attr('stroke',"")
      // svg.select(getCircleAttributeString(p2))
      // .attr('r', 3)
      // .attr('stroke',"")
      
      // console.log("Hi")
      console.info(`Remaining points: ${points.length}`)
      await recurrantStep()
      // console.info("loading")
      await sleep(slider.value * 10)
      if(S1.includes(p)){
        tpoint1.push(p)
        if(tpoint1.length > 3){
          redrawDelaunay(Delaunator.from(tpoint1), tpoint1, tlines1)
        }
      } else {
        tpoint2.push(p)
        if(tpoint2.length > 3){
          redrawDelaunay(Delaunator.from(tpoint2), tpoint2, tlines2)
        }
      }
      d3.select(getCircleAttributeString(p))
      .attr('stroke','')
      .attr('stroke-width', '')
      .attr('r', 5)
      d3.selectAll(`circle`).raise()
      
    }
    await recurrantStep()
    // for(let i = 0; i < points.length; i++){
    //   await sleep(500)
    //   svg.select(getCircleAttributeString(points[i]))
    //   .attr('fill', 'red')
    //   console.log(points[i])
    // }
  }
  doSomething();
}

function magnitudeSquared(p1, p2){
  return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1])
}
function getCircleAttributeString(point){
  return `circle[cx='${point[0]}'][cy='${point[1]}']`
}

function getLineAttributeString(p1, p2){
  var a = p1,b=p2;
  if(p1[0] > p2[0]){
    a = p2
    b = p1
  } else if (p1[0] == p2[0]){
    if(p1[1] > p2[1]){
      a = p2
      b = p1
    }
  }
  return `line[x1='${a[0]}'][x2='${b[0]}'][y1='${a[1]}'][y2='${b[1]}']`
}

function drawEdge(p1, p2) {
  var a = p1,b=p2;
  if(p1[0] > p2[0]){
    a = p2
    b = p1
  } else if (p1[0] == p2[0]){
    if(p1[1] > p2[1]){
      a = p2
      b = p1
    }
  }
  return svg.append("line")
  .attr("x1", a[0])
  .attr("y1", a[1])
  .attr("x2", b[0])
  .attr("y2", b[1])
  .attr("stroke-width", 2)
  .attr("stroke", "lightgrey");
}

function drawSearchRadius(point, radius){
  return svg.append('circle')
  .attr('cx', point[0])
  .attr('cy', point[1])
  .attr('fill', 'transparent')
  .attr('r', radius)
  .attr('stroke', red)
}



function edgesOfTriangle(t) { return [3 * t, 3 * t + 1, 3 * t + 2]; }
function triangleOfEdge(e)  { return Math.floor(e / 3); }
function nextHalfedge(e) { return (e % 3 === 2) ? e - 2 : e + 1; }
function prevHalfedge(e) { return (e % 3 === 0) ? e + 2 : e - 1; }

function forEachTriangleEdge(points, delaunay, callback) {
    for (let e = 0; e < delaunay.triangles.length; e++) {
        if (e > delaunay.halfedges[e]) {
            const p = points[delaunay.triangles[e]];
            const q = points[delaunay.triangles[nextHalfedge(e)]];
            callback(e, p, q);

        }
    }
}

function edgesOfTriangle(t) { return [3 * t, 3 * t + 1, 3 * t + 2]; }

function pointsOfTriangle(delaunay, t) {
    return edgesOfTriangle(t)
        .map(e => delaunay.triangles[e]);
}

function forEachTriangle(points, delaunay, callback) {
    for (let t = 0; t < delaunay.triangles.length / 3; t++) {
        callback(t, pointsOfTriangle(delaunay, t).map(p => points[p]));
    }
}

</script>

<style>



.triangles {
  fill: none;
}

.links {
  stroke: #000;
}

.sites {
  fill: #000;
  stroke: #fff;
}

.triangles .primary {
  fill: #f00;
}

.links .primary {
  stroke: #fff;
}

.sites :first-child {
  fill: #fff;
}

.title {
  font-family: Arial;
}

.boxed {
  text-align: right;
  padding: 20px;
  border: 2px solid lightgrey;
  border-left: 0px;
  border-right: 0px;
  border-bottom: 0px;
  float: right;
  height: 500px;
  position: relative;
}


.image {
  background-color: white;
}

.interface {
    width: 200%;
    border: 2px solid lightgrey;
    padding: 30px;
    margin: 0px;
    text-align: center;
    border-left: 0px;
    border-bottom: 0px;
    float: left;


}

.interface:after {
  content: '';
  display: block;
  position: absolute;
  height: 15px;
  width: 30px;
  top: 0px;
  right: -5px;
  border: 5px solid white;
}


.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  
}


.button1 {
  background-color: #f44336; 
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
}

.button2 {
  background-color: #008CBA;
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
}

.slidecontainer {
  width: 100%; 
  position: relative;
  top: 30%;
}

.slider {
  -webkit-appearance: none;  
  appearance: none;
  width: 100%; 
  height: 15px; 
  background: #d3d3d3; 
  outline: none;
  opacity: 0.7; 
  -webkit-transition: .2s; 
  transition: opacity .2s;
  
  top: 40%;
  transform: rotate(270deg);
}


.slider:hover {
  opacity: 1; 
}


.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: black;
  cursor: pointer;
}

.border {
  display: flex;
}

.consolebox {
  width: 20vw;
  height: 15%;
  padding: 10px;
  border: 2px solid grey;
  margin: 0;
  position: relative;
  top: 55%;
  text-align: left;

}


</style>

</body>
